require_relative '../helpers/minitest_helper'
require_relative '../helpers/create_doe_prototype_helper'

# Test suite for the ASHRAE 90.1 appendix G Performance
# Rating Method (PRM) baseline automation implementation
# in openstudio-standards.
# @author Doug Maddox (PNNL), Jeremy Lerond (PNNL), and Yunyang Ye (PNNL)
class AppendixGPRMTests < Minitest::Test
  # Set folder for JSON files related to tests and
  # parse individual JSON files used by all methods
  # in this class.
  @@json_dir = "#{File.dirname(__FILE__)}/data"
  @@prototype_list = JSON.parse(File.read("#{@@json_dir}/prototype_list.json"))
  @@wwr_building_types = JSON.parse(File.read("#{@@json_dir}/wwr_building_types.json"))
  @@hvac_building_types = JSON.parse(File.read("#{@@json_dir}/hvac_building_types.json"))
  @@swh_building_types = JSON.parse(File.read("#{@@json_dir}/swh_building_types.json"))
  @@wwr_values = JSON.parse(File.read("#{@@json_dir}/wwr_values.json"))
  @@hasres_values = JSON.parse(File.read("#{@@json_dir}/hasres_values.json"))

  # Generate one of the ASHRAE 90.1 prototype model included in openstudio-standards.
  #
  # @param prototypes_to_generate [Array] List of prototypes to generate, see prototype_list.json to see the structure of the list
  #
  # @return [Hash] Hash of OpenStudio Model of the prototypes
  def generate_prototypes(prototypes_to_generate)
    prototypes = {}
    @lpd_space_types_alt = {}
    @bldg_type_alt = {}
    @bldg_type_alt_now = nil

    prototypes_to_generate.each do |id, prototype|
      # mod is an array of method intended to modify the model
      building_type, template, climate_zone, mod = prototype

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      # Initialize weather file, necessary but not used
      epw_file = 'USA_FL_Miami.Intl.AP.722020_TMY3.epw'

      # Create output folder if it doesn't already exist
      @test_dir = "#{File.dirname(__FILE__)}/output"
      if !Dir.exist?(@test_dir)
        Dir.mkdir(@test_dir)
      end

      # Define model name and run folder if it doesn't already exist,
      # if it does, remove it and re-create it.
      model_name = mod.empty? ? "#{building_type}-#{template}-#{climate_zone}" : "#{building_type}-#{template}-#{climate_zone}-#{mod_str}"
      run_dir = "#{@test_dir}/#{model_name}"
      if !Dir.exist?(run_dir)
        Dir.mkdir(run_dir)
      else
        FileUtils.rm_rf(run_dir)
        Dir.mkdir(run_dir)
      end

      # Create the prototype
      @prototype_creator = Standard.build("#{template}_#{building_type}")
      model = @prototype_creator.model_create_prototype_model(climate_zone, epw_file, run_dir)

      # Make modification if requested
      @bldg_type_alt_now = nil
      if !mod.empty?
        mod.each do |method_mod|
          mthd, arguments = method_mod
          model = public_send(mthd, model, arguments)
        end
      end

      # Store alternate building type into hash
      if !@bldg_type_alt_now.nil?
        @bldg_type_alt[prototype] = @bldg_type_alt_now
      else
        @bldg_type_alt[prototype] = nil?
      end

      # Save prototype OSM file
      osm_path = OpenStudio::Path.new("#{run_dir}/#{model_name}.osm")
      model.save(osm_path, true)

      # Translate prototype model to an IDF file
      forward_translator = OpenStudio::EnergyPlus::ForwardTranslator.new
      idf_path = OpenStudio::Path.new("#{run_dir}/#{model_name}.idf")
      idf = forward_translator.translateModel(model)
      idf.save(idf_path, true)

      # Save OpenStudio model object
      prototypes[id] = model
    end
    return prototypes
  end

  # Generate the 90.1 Appendix G baseline for a model following the 90.1-2019 PRM rules
  #
  # @param prototypes_generated [Array] List of all unique prototypes for which baseline models will be created
  # @param id_prototype_mapping [Hash] Mapping of prototypes to their identifiers generated by prototypes_to_generate()
  #
  # @return [Hash] Hash of OpenStudio Model of the prototypes
  def generate_baseline(prototypes_generated, id_prototype_mapping)
    baseline_prototypes = {}
    prototypes_generated.each do |id, proposed_model|
      building_type, template, climate_zone, mod = id_prototype_mapping[id]

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      # Create a deep copy of the proposed model
      model = BTAP::FileIO::deep_copy(proposed_model)

      # Initialize Standard class
      @prototype_creator = Standard.build('90.1-PRM-2019')

      # Convert standardSpaceType string for each space to values expected for prm creation
      lpd_space_types = JSON.parse(File.read("#{@@json_dir}/lpd_space_types.json"))
      model.getSpaceTypes.sort.each do |space_type|
        next if space_type.floorArea == 0

        standards_space_type = if space_type.standardsSpaceType.is_initialized
                                 space_type.standardsSpaceType.get
                               end
        std_bldg_type = space_type.standardsBuildingType.get
        bldg_type_space_type = std_bldg_type + space_type.standardsSpaceType.get
        new_space_type = lpd_space_types[bldg_type_space_type]
        alt_space_type_was_found = false
        unless @lpd_space_types_alt.nil?
          # Check alternate hash of LPD space types before replacing from JSON list
          @lpd_space_types_alt.each do |alt_bldg_space_type, n_spc_t|
            if bldg_type_space_type == alt_bldg_space_type
              alt_space_type_was_found = true
              space_type.setStandardsSpaceType(n_spc_t)
              break
            end
          end
        end
        if alt_space_type_was_found == false
          space_type.setStandardsSpaceType(lpd_space_types[bldg_type_space_type])
        end
      end

      # Define run directory and run name, delete existing folder if it exists
      model_name = mod.empty? ? "#{building_type}-#{template}-#{climate_zone}" : "#{building_type}-#{template}-#{climate_zone}-#{mod_str}"
      run_dir = "#{@test_dir}/#{model_name}"
      run_dir_baseline = "#{run_dir}-Baseline"
      if Dir.exist?(run_dir_baseline)
        FileUtils.rm_rf(run_dir_baseline)
      end

      if @bldg_type_alt[id_prototype_mapping[id]] == false
        hvac_building_type = building_type
      else
        hvac_building_type = @bldg_type_alt[id_prototype_mapping[id]]
      end

      # Create baseline model
      model_baseline = @prototype_creator.model_create_prm_stable_baseline_building(model, building_type, climate_zone,
                                                                                    @@hvac_building_types[hvac_building_type],
                                                                                    @@wwr_building_types[building_type],
                                                                                    @@swh_building_types[building_type],
                                                                                    nil, run_dir_baseline, false, false)

      # Check if baseline could be created
      assert(model_baseline, "Baseline model could not be generated for #{building_type}, #{template}, #{climate_zone}.")

      # Load newly generated baseline model
      @test_dir = "#{File.dirname(__FILE__)}/output"
      model_baseline_file_name = mod.empty? ? "#{building_type}-#{template}-#{climate_zone}-Baseline/final.osm" : "#{building_type}-#{template}-#{climate_zone}-#{mod_str}-Baseline/final.osm"
      model_baseline = OpenStudio::Model::Model.load("#{@test_dir}/#{model_baseline_file_name}")
      model_baseline = model_baseline.get

      # Do sizing run for baseline model
      sim_control = model_baseline.getSimulationControl
      sim_control.setRunSimulationforSizingPeriods(true)
      sim_control.setRunSimulationforWeatherFileRunPeriods(false)
      baseline_run = @prototype_creator.model_run_simulation_and_log_errors(model_baseline, "#{@test_dir}/#{model_baseline_file_name}-SR")

      # Add prototype to the list of baseline prototypes generated
      baseline_prototypes[id] = model_baseline
    end
    return baseline_prototypes
  end

  # Write out a SQL query to retrieve simulation outputs
  # from the TabularDataWithStrings table in the SQL
  # database produced by OpenStudio/EnergyPlus after
  # running a simulation.
  #
  # @param model [OpenStudio::Model::Model] OpenStudio model object
  # @param report_name [String] Name of the report as defined in the HTM simulation output file
  # @param table_name [String] Name of the table as defined in the HTM simulation output file
  # @param row_name [String] Name of the row as defined in the HTM simulation output file
  # @param column_name [String] Name of the column as defined in the HTM simulation output file
  # @param units [String] Unit of the value to be retrieved
  #
  # @return [String] Result of the query
  def run_query_tabulardatawithstrings(model, report_name, table_name, row_name, column_name, units = '*')
    # Define the query
    query = "Select Value FROM TabularDataWithStrings WHERE
    ReportName = '#{report_name}' AND
    TableName = '#{table_name}' AND
    RowName = '#{row_name}' AND
    ColumnName = '#{column_name}' AND
    Units = '#{units}'"
    # Run the query if the expected output is a string
    return model.sqlFile.get.execAndReturnFirstString(query).get if units.empty?

    # Run the query if the expected output is a double
    return model.sqlFile.get.execAndReturnFirstDouble(query).get
  end

  # Identify individual prototypes to be created
  #
  # @param tests [Array] Names of the tests to be performed
  # @param prototype_list [Hash] List of prototypes needed for each test
  #
  # @return [Hash] Prototypes to be generated
  def get_prototype_to_generate(tests, prototype_list)
    # Initialize prototype identifier
    id = 0
    # Associate model description to identifiers
    prototypes_to_generate = {}
    prototype_list.each do |utest, prototypes|
      prototypes.each do |prototype|
        if !prototypes_to_generate.values.include?(prototype) && tests.include?(utest)
          prototypes_to_generate[id] = prototype
          id += 1
        end
      end
    end
    return prototypes_to_generate
  end

  # Assign prototypes to each individual tests
  #
  # @param prototypes_generated [Hash] Hash containing all the OpenStudio model objects of the prototypes that have been created
  # @param tests [Array] List of tests to be performed
  # @param id_prototype_mapping [Hash] Mapping of prototypes to their respective ids
  #
  # @return [Hash] Association of OpenStudio model object to model description for each test
  def assign_prototypes(prototypes_generated, tests, id_prototype_mapping)
    test_prototypes = {}
    tests.each do |test|
      test_prototypes[test] = {}
      @@prototype_list[test].each do |prototype|
        # Find prototype id in mapping
        prototype_id = -9999.0
        id_prototype_mapping.each do |id, prototype_description|
          if prototype_description == prototype
            prototype_id = id
          end
        end
        test_prototypes[test][prototype] = prototypes_generated[prototype_id]
      end
    end
    return test_prototypes
  end

  # Check Window-to-Wall Ratio (WWR) for the baseline models
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_wwr(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype

      # Get WWR of baseline model
      wwr_baseline = run_query_tabulardatawithstrings(model_baseline, 'InputVerificationandResultsSummary', 'Conditioned Window-Wall Ratio', 'Gross Window-Wall Ratio', 'Total', '%').to_f

      # Check WWR against expected WWR
      wwr_goal = 100 * @@wwr_values[building_type].to_f
      assert((wwr_baseline - wwr_goal).abs < 0.1, "Baseline WWR for the #{building_type}, #{template}, #{climate_zone} model is incorrect. The WWR of the baseline model is #{wwr_baseline} but should be #{wwr_goal}.")
    end
  end

  # Check Skylight-to-Roof Ratio (SRR) for the baseline models
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_srr(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype

      # Get srr of baseline model
      srr_baseline = run_query_tabulardatawithstrings(model_baseline, 'InputVerificationandResultsSummary', 'Skylight-Roof Ratio', 'Skylight-Roof Ratio', 'Total', '%').to_f

      # Check WWR against expected WWR
      srr_goal = 3
      assert((srr_baseline - srr_goal).abs < 0.1, "Baseline SRR for the #{building_type}, #{template}, #{climate_zone} model is incorrect. The SRR of the baseline model is #{srr_baseline} but should be #{srr_goal}.")
    end
  end

  # Check that no daylighting controls are modeled in the baseline models
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_daylighting_control(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype
      # Check the model include daylighting control objects
      model_baseline.getSpaces.sort.each do |space|
        existing_daylighting_controls = space.daylightingControls
        assert(existing_daylighting_controls.empty?, "The baseline model for the #{building_type}-#{template} in #{climate_zone} has daylighting control.")
      end
    end
  end

  # Check if the IsResidential flag used by the PRM works as intended (i.e. should be false for commercial spaces)
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_residential_flag(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype
      # Determine whether any space is residential
      has_res = 'false'
      std = Standard.build("#{template}_#{building_type}")
      model_baseline.getSpaces.sort.each do |space|
        if std.space_residential?(space)
          has_res = 'true'
        end
      end
      # Check whether space_residential? function is working
      has_res_goal = @@hasres_values[building_type]
      assert(has_res == has_res_goal, "Failure to set space_residential? for #{building_type}, #{template}, #{climate_zone}.")
    end
  end

  # Check envelope requirements lookups
  #
  # @param prototypes_base [Hash] Baseline prototypes
  #
  # TODO: Add residential and semi-heated spaces lookup
  def check_envelope(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      # Define name of surfaces used for verification
      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod_str}"

      opaque_exterior_name = JSON.parse(File.read("#{@@json_dir}/envelope.json"))[run_id]['opaque_exterior_name']
      exterior_fenestration_name = JSON.parse(File.read("#{@@json_dir}/envelope.json"))[run_id]['exterior_fenestration_name']
      exterior_door_name = JSON.parse(File.read("#{@@json_dir}/envelope.json"))[run_id]['exterior_door_name']

      # Get U-value of envelope in baseline model
      u_value_baseline = {}
      construction_baseline = {}
      opaque_exterior_name.each do |val|
        u_value_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'EnvelopeSummary', 'Opaque Exterior', val[0], 'U-Factor with Film', 'W/m2-K').to_f
        construction_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'EnvelopeSummary', 'Opaque Exterior', val[0], 'Construction', '').to_s
      end
      exterior_fenestration_name.each do |val|
        u_value_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'EnvelopeSummary', 'Exterior Fenestration', val[0], 'Glass U-Factor', 'W/m2-K').to_f
        construction_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'EnvelopeSummary', 'Exterior Fenestration', val[0], 'Construction', '').to_s
      end
      exterior_door_name.each do |val|
        u_value_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'EnvelopeSummary', 'Exterior Door', val[0], 'U-Factor with Film', 'W/m2-K').to_f
        construction_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'EnvelopeSummary', 'Exterior Door', val[0], 'Construction', '').to_s
      end

      # Check U-value against expected U-value
      u_value_goal = opaque_exterior_name + exterior_fenestration_name + exterior_door_name
      u_value_goal.each do |key, value|
        value_si = OpenStudio.convert(value, 'Btu/ft^2*hr*R', 'W/m^2*K').get
        assert(((u_value_baseline[key] - value_si).abs < 0.001 || u_value_baseline[key] == 5.838), "Baseline U-value for the #{building_type}, #{template}, #{climate_zone} model is incorrect. The U-value of the #{key} is #{u_value_baseline[key]} but should be #{value_si}.")
        if key != 'PERIMETER_ZN_3_WALL_NORTH_DOOR1'
          assert((construction_baseline[key].include? 'PRM'), "Baseline U-value for the #{building_type}, #{template}, #{climate_zone} model is incorrect. The construction of the #{key} is #{construction_baseline[key]}, which is not from PRM_Construction tab.")
        end
      end
    end
  end

  # Check LPD requirements lookups
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_lpd(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      # Define name of spaces used for verification
      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod_str}"
      space_name = JSON.parse(File.read("#{@@json_dir}/lpd.json"))[run_id]

      # Get LPD in baseline model
      lpd_baseline = {}
      space_name.each do |val|
        lpd_baseline[val[0]] = run_query_tabulardatawithstrings(model_baseline, 'LightingSummary', 'Interior Lighting', val[0], 'Lighting Power Density', 'W/m2').to_f
      end

      # Check LPD against expected LPD
      space_name.each do |key, value|
        value_si = OpenStudio.convert(value, 'W/ft^2', 'W/m^2').get
        assert(((lpd_baseline[key] - value_si).abs < 0.001), "Baseline U-value for the #{building_type}, #{template}, #{climate_zone} model is incorrect. The U-value of the #{key} is #{lpd_baseline[key]} but should be #{value_si}.")
      end
    end
  end

  # Check lighting occ sensor
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_light_occ_sensor(prototypes, prototypes_base)
    light_sch = {}
    prototypes.each do |prototype, model_proto|
      building_type, template, climate_zone, mod = prototype
      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod}"
      # Define name of spaces used for verification
      space_name = JSON.parse(File.read("#{@@json_dir}/light_occ_sensor.json"))[run_id]

      # Get lighting schedule in prototype model
      light_sch_model = {}
      model_proto.getLightss.sort.each do |lgts|
        light_sch_model_lgts = {}

        # get default schedule
        day_rule = lgts.schedule.get.to_ScheduleRuleset.get.defaultDaySchedule
        times = day_rule.times()
        light_sch_model_default_rule = {}
        times.each do |time|
          light_sch_model_default_rule[time.to_s] = day_rule.getValue(time)
        end
        light_sch_model_lgts['default schedule'] = light_sch_model_default_rule

        # get daily schedule
        lgts.schedule.get.to_ScheduleRuleset.get.scheduleRules.each do |week_rule|
          light_sch_model_week_rule = {}
          day_rule = week_rule.daySchedule
          times = day_rule.times()
          times.each do |time|
            light_sch_model_week_rule[time.to_s] = day_rule.getValue(time)
          end
          light_sch_model_lgts[week_rule.name.to_s] = light_sch_model_week_rule
        end
        light_sch_model[lgts.name.to_s] = light_sch_model_lgts
      end
      light_sch[run_id] = light_sch_model
    end

    light_sch_base = {}
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype
      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod}"
      # Define name of spaces used for verification
      space_name = JSON.parse(File.read("#{@@json_dir}/light_occ_sensor.json"))[run_id]

      # Get lighting schedule in baseline model
      model_baseline.getSpaceTypes.sort.each do |space_type|
        light_sch_model_base = {}
        space_type.lights.sort.each do |lgts|
          light_sch_model_lgts_base = {}
          light_sch_model_lgts_base['space_type'] = space_type.standardsSpaceType.to_s

          # get default schedule
          day_rule = lgts.schedule.get.to_ScheduleRuleset.get.defaultDaySchedule
          times = day_rule.times()
          light_sch_model_default_rule = {}
          times.each do |time|
            light_sch_model_default_rule[time.to_s] = day_rule.getValue(time)
          end
          light_sch_model_lgts_base['default schedule'] = light_sch_model_default_rule

          # get daily schedule
          lgts.schedule.get.to_ScheduleRuleset.get.scheduleRules.each do |week_rule|
            light_sch_model_week_rule_base = {}
            day_rule = week_rule.daySchedule
            times = day_rule.times()
            times.each do |time|
              light_sch_model_week_rule_base[time.to_s] = day_rule.getValue(time)
            end
            light_sch_model_lgts_base[week_rule.name.to_s] = light_sch_model_week_rule_base
          end
          light_sch_model_base[lgts.name.to_s] = light_sch_model_lgts_base
        end

        # Check light schedule against expected light schedule
        light_sch_model_base.each do |key, value|
          value.each do |key1, value1|
            if key1 != 'space_type'
              value1.each do |key2, value2|
                space_type_var = 0
                space_name.each do |key3, value3|
                  if value['space_type'] == key3
                    space_type_var = value3
                  end
                end
                assert(((light_sch[run_id][key][key1][key2] - value2 * (1.0 - space_type_var)).abs < 0.001), "Lighting schedule for the #{building_type}, #{template}, #{climate_zone} model is incorrect.")
              end
            end
          end
        end
      end
    end
  end

  # Check baseline infiltration calculations
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_infiltration(prototypes, prototypes_base)
    std = Standard.build('90.1-PRM-2019')
    space_env_areas = JSON.parse(File.read("#{@@json_dir}/space_envelope_areas.json"))

    # Check that the model_get_infiltration_method and
    # model_get_infiltration_coefficients method retrieve
    # the correct information
    model_blank = OpenStudio::Model::Model.new
    infil_object = OpenStudio::Model::SpaceInfiltrationDesignFlowRate.new(model_blank)
    infil_object.setFlowperExteriorWallArea(0.001)
    infil_object.setConstantTermCoefficient(0.002)
    infil_object.setTemperatureTermCoefficient(0.003)
    infil_object.setVelocityTermCoefficient(0.004)
    infil_object.setVelocitySquaredTermCoefficient(0.005)
    new_space = OpenStudio::Model::Space.new(model_blank)
    infil_object.setSpace(new_space)
    assert(infil_object.designFlowRateCalculationMethod.to_s == std.model_get_infiltration_method(model_blank), 'Error in infiltration method retrieval.')
    assert(std.model_get_infiltration_coefficients(model_blank) == [infil_object.constantTermCoefficient,
                                                                    infil_object.temperatureTermCoefficient,
                                                                    infil_object.velocityTermCoefficient,
                                                                    infil_object.velocitySquaredTermCoefficient], 'Error in infiltration coeffcient retrieval.')

    # Retrieve space envelope area for input prototypes
    prototypes_spc_area_calc = {}
    prototypes.each do |prototype, model|
      building_type, template, climate_zone, mod = prototype
      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod}"

      # Get space envelope area
      spc_env_area = 0
      model.getSpaces.sort.each do |spc|
        spc_env_area += std.space_envelope_area(spc, climate_zone)
      end

      prototypes_spc_area_calc[prototype] = spc_env_area
    end

    prototypes_base.each do |prototype, model|
      building_type, template, climate_zone, mod = prototype

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod_str}"

      # Check if the space envelope area calculations
      spc_env_area = 0
      model.getSpaces.sort.each do |spc|
        spc_env_area += std.space_envelope_area(spc, climate_zone)
      end
      assert((space_env_areas[run_id].to_f - spc_env_area.round(2)).abs < 0.001, "Space envelope calculation is incorrect for the #{building_type}, #{template}, #{climate_zone} model: #{spc_env_area.round(2)} (model) vs. #{space_env_areas[run_id]} (expected).")

      # Check that infiltrations are not assigned at
      # the space type level
      model.getSpaceTypes.sort.each do |spc|
        assert(false, "The baseline for the #{building_type}, #{template}, #{climate_zone} model has infiltration specified at the space type level.") unless spc.spaceInfiltrationDesignFlowRates.empty?
      end

      # Back calculate the I_75 (cfm/ft2), expected value is 1 cfm/ft2 in 90.1-PRM-2019
      # Use input prototype's space envelope area because, even though the baseline model space
      # conditioning can be different, 90.1-2019 Appendix G specified that:
      # "The baseline building design shall be modeled with the same number of floors and
      # identical conditioned floor area as the proposed design."
      # So it is assumed that the baseline space conditioning category shall be the same as the proposed.
      conv_fact = OpenStudio.convert(1, 'm^3/s', 'ft^3/min').to_f / OpenStudio.convert(1, 'm^2', 'ft^2').to_f
      assert((std.model_current_building_envelope_infiltration_at_75pa(model, prototypes_spc_area_calc[prototype]) * conv_fact).round(2) == 1.0, 'The baseline air leakage rate of the building envelope at a fixed building pressure of 75 Pa is different that the requirement (1 cfm/ft2).')
    end
  end

  # Check hvac baseline system type selections
  # Expected outcome depends on prototype name and 'mod' variation defined with
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_hvac_type(prototypes_base)
    prototypes_base.each do |prototype, model|
      building_type, template, climate_zone, mod = prototype

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      run_id = "#{building_type}_#{template}_#{climate_zone}_#{mod_str}"
      @bldg_type_alt_now = @bldg_type_alt[prototype]

      if building_type == 'MidriseApartment' && mod_str == ''
        # Residential model should be ptac or pthp, depending on climate
        check_if_pkg_terminal(model, climate_zone, 'MidriseApartment')
      elsif @bldg_type_alt_now == 'Assembly' && building_type == 'MediumOffice'
        # This is a public assembly < 120 ksf, should be PSZ
        check_if_psz(model, 'Assembly < 120,000 sq ft.')
        check_heat_type(model, climate_zone, 'SZ', 'HeatPump')
      elsif @bldg_type_alt_now == 'Assembly' && building_type == 'LargeHotel'
        # This is a public assembly > 120 ksf, should be SZ-CV
        check_if_sz_cv(model, climate_zone, 'Assembly < 120,000 sq ft.')
      elsif building_type == 'Warehouse' && mod_str == ''
        # System type should be heating and ventilating
        # check_if_ht_vent(model, "Warehouse")
        check_heat_type(model, climate_zone, '??????SZ???????', 'Electric')
      elsif building_type == 'RetailStripmall' && mod_str == ''
        # System type should be PSZ
        check_if_psz(model, 'RetailStripmall, one story, any area')
      elsif @bldg_type_alt_now == 'Retail' && building_type == 'PrimarySchool'
        # Single story retail is PSZ, regardless of floor area
        check_if_psz(model, 'retail, one story, floor area > 25 ksf.')
      elsif building_type == 'RetailStripmall' && mod_str == 'set_zone_multiplier_3'
        # System type should be PVAV with 10 zones
        check_if_pvav(model, 'retail > 25,000 sq ft, 3 stories')
      elsif building_type == 'SmallOffice' && mod_str == ''
        # System type should be PSZ
        check_if_psz(model, 'non-res, one story, < 25 ksf')
        check_heat_type(model, climate_zone, 'SZ', 'HeatPump')
      elsif building_type == 'PrimarySchool' && mod_str == ''
        # System type should be PVAV, some zones may be on PSZ systems
        check_if_pvav(model, 'nonres > 25,000 sq ft, < 150 ksf , 1 story')
        check_heat_type(model, climate_zone, 'MZ', 'Electric')
      elsif building_type == 'SecondarySchool' && mod_str == ''
        # System type should be VAV/chiller
        check_if_vav_chiller(model, 'nonres > 150 ksf , 1 to 3 stories')
        check_heat_type(model, climate_zone, 'MZ', 'Electric')
      elsif building_type == 'SmallOffice' && mod_str == 'set_zone_multiplier_4'
        # nonresidential, 4 to 5 stories, <= 25 ksf --> PVAV
        # System type should be PVAV with 10 zones, area is 22,012 sf
        check_if_pvav(model, 'other nonres > 4 to 5 stories, <= 25 ksf')
      elsif building_type == 'SmallOffice' && mod_str == 'set_zone_multiplier_5'
        # nonresidential, 4 to 5 stories, <= 150 ksf --> PVAV
        # System type should be PVAV with 10 zones, area is 27,515 sf
        check_if_pvav(model, 'other nonres > 4 to 5 stories, <= 150 ksf')
      elsif building_type == 'PrimarySchool' && mod_str == 'set_zone_multiplier_4'
        # nonresidential, 4 to 5 stories, > 150 ksf --> VAV/chiller
        # System type should be PVAV with 10 zones, area is 22,012 sf
        check_if_vav_chiller(model, 'other nonres > 4 to 5 stories, > 150 ksf')
      elsif building_type == 'SmallOffice' && mod_str == 'set_zone_multiplier_6'
        # 6+ stories, any floor area --> VAV/chiller
        # This test has floor area 33,018 sf
        check_if_vav_chiller(model, ' other nonres > 6 stories')
      elsif @bldg_type_alt_now == 'Hospital' && building_type == 'SmallOffice'
        # Hospital < 25 ksf is PVAV; different rule than non-res
        check_if_pvav(model, 'hospital, floor area < 25 ksf.')
      elsif building_type == 'Hospital' && mod_str == ''
        # System type should be VAV/chiller, area is 241 ksf
        check_if_vav_chiller(model, 'hospital > 4 to 5 stories, > 150 ksf')
        check_heat_type(model, climate_zone, 'MZ', 'Fuel')
      elsif mod_str == 'make_lab_high_distrib_zone_exh' || mod_str == 'make_lab_high_system_exh'
        # All labs on a given floor of the building should be on a separate MZ system
        model.getAirLoopHVACs.each do |air_loop|
          # identify hours of operation
          has_lab = false
          has_nonlab = false
          air_loop.thermalZones.each do |thermal_zone|
            thermal_zone.spaces.each do |space|
              space_type = space.spaceType.get.standardsSpaceType.get
              if space_type == 'laboratory'
                has_lab = true
              else
                has_nonlab = true
              end
            end
          end
          assert(!(has_lab == true && has_nonlab == true), "System #{air_loop.name} has lab and nonlab spaces and lab exhaust > 15,000 cfm.")
        end
      elsif mod_str == 'make_lab_low_distrib_zone_exh'
        # Labs on a given floor of the building should be mixed with other space types on the main MZ system
        model.getAirLoopHVACs.each do |air_loop|
          # identify hours of operation
          has_lab = false
          has_nonlab = false
          air_loop.thermalZones.each do |thermal_zone|
            thermal_zone.spaces.each do |space|
              space_type = space.spaceType.get.standardsSpaceType.get
              if space_type == 'laboratory'
                has_lab = true
              else
                has_nonlab = true
              end
            end
          end
          assert(!(has_lab == true && has_nonlab == false), "System #{air_loop.name} has only lab spaces and lab exhaust < 15,000 cfm.")
        end
      elsif building_type == 'LargeOffice' || building_type == 'MediumOffice'
        # Check that the datacenter basement is assigned to system 11, PSZ-VAV
        check_cmp_dtctr_system_type(model)
      end
    end
  end

  # Check whether heat type meets expectations
  # Electric if warm CZ, fuel if cold
  # Also check HP vs electric resistance depending on baseline system type
  # @param model, climate_zone, mz_or_sz, expected_elec_heat_type
  # mz_or_sz = MZ or SZ or PTU
  # expected_elec_heat_type = Electric or HeatPump
  def check_heat_type(model, climate_zone, mz_or_sz, expected_elec_heat_type)
    return false unless model.getAirLoopHVACs.size > 0

    model.getAirLoopHVACs.each do |air_loop|
      num_zones = air_loop.thermalZones.size
      if (num_zones > 1 && mz_or_sz == 'MZ') || (num_zones == 1 && mz_or_sz == 'SZ')
        # This is a multizone system, do the test
        heat_type = model.airloop_primary_heat_type(air_loop).to_s
        if climate_zone =~ /0A|0B|1A|1B|2A|2B|3A/
          # Heat type is electric or heat pump
          assert(heat_type == expected_elec_heat_type, "Incorrect heat type for #{air_loop.name.get}; expected #{expected_elec_heat_type}")
        else
          # Heat type is Fuel
          assert(heat_type == 'Fuel', "Incorrect heat type for #{air_loop.name.get}; expected Fuel")
        end
      end
    end

    # TODO: Also check zone equipment
    # if mz_or_sz == 'PTU' || mz_or_sz == 'SZ'
    # end
  end

  # Check if all baseline system types are PSZ
  # @param model, sub_text for error messages
  def check_if_psz(model, sub_text, zone: nil)
    num_zones = 0
    num_dx_coils = 0
    num_dx_coils += model.getCoilCoolingDXSingleSpeeds.size
    num_dx_coils += model.getCoilCoolingDXTwoSpeeds.size
    num_dx_coils += model.getCoilCoolingDXMultiSpeeds.size
    has_chiller = model.getPlantLoopByName('Chilled Water Loop').is_initialized
    model.getAirLoopHVACs.each do |air_loop|
      if zone.nil?
        num_zones = air_loop.thermalZones.size
        # if num zones is greater than 1 for any system, then set as multizone
        assert(num_zones = 1 && num_dx_coils > 0 && has_chiller == false, "Baseline system selection failed for #{air_loop.name}; should be PSZ for " + sub_text)
      else
        th_zones = []
        air_loop.thermalZones.each { |th_zone| th_zones << th_zone.name.to_s }
        if th_zones.include? zone
          # If multizone system
          return false if air_loop.thermalZones.size > 1

          zone_system_check = false
          model.getAirLoopHVACUnitarySystems.each do |unit_system|
            # Check if airloop includes a unitary system with constant volume fan single speed DX cooling coil
            zone_system_check = true if unit_system.controllingZoneorThermostatLocation.get.name.to_s == zone.name.to_s &&
                                        unit_system.controlType == 'Load' &&
                                        unit_system.coolingCoil.get.to_CoilCoolingDXSingleSpeed.is_initialized &&
                                        unit_system.supplyFan.get.to_FanOnOff.is_initialized
          end
          return zone_system_check
        end
      end
    end
  end

  # Check if any baseline system type is PVAV
  # @param model, sub_text for error messages
  def check_if_pvav(model, sub_text)
    num_zones = 0
    num_dx_coils = 0
    num_dx_coils += model.getCoilCoolingDXSingleSpeeds.size
    num_dx_coils += model.getCoilCoolingDXTwoSpeeds.size
    num_dx_coils += model.getCoilCoolingDXMultiSpeeds.size
    has_chiller = model.getPlantLoopByName('Chilled Water Loop').is_initialized
    has_multizone = false
    model.getAirLoopHVACs.each do |air_loop|
      num_zones = air_loop.thermalZones.size
      # if num zones is greater than 1 for any system, then set as multizone
      if num_zones > 1
        has_multizone = true
      end
    end
    assert(has_multizone && num_dx_coils > 0 && has_chiller == false, 'Baseline system selection failed; should be PVAV for ' + sub_text)
  end

  # Check if building has baseline VAV/chiller for at least one air loop
  # @param model, sub_text for error messages
  def check_if_vav_chiller(model, sub_text)
    num_zones = 0
    num_dx_coils = 0
    has_chiller = model.getPlantLoopByName('Chilled Water Loop').is_initialized
    has_multizone = false
    model.getAirLoopHVACs.each do |air_loop|
      num_zones = air_loop.thermalZones.size
      # if num zones is greater than 1 for any system, then set as multizone
      if num_zones > 1
        has_multizone = true
      end
    end
    assert(has_multizone && has_chiller, 'Baseline system selection failed; should be VAV/chiller for ' + sub_text)
  end

  # Check if baseline system type is PTAC or PTHP
  # @param model, sub_text for error messages
  def check_if_pkg_terminal(model, climate_zone, sub_text)
    pass_test = true
    # building fails if any zone is not packaged terminal unit
    # or if heat type is incorrect
    model.getThermalZones.sort.each do |thermal_zone|
      has_ptac = false
      has_pthp = false
      has_unitheater = false
      thermal_zone.equipment.each do |equip|
        # Skip HVAC components
        next unless equip.to_HVACComponent.is_initialized

        equip = equip.to_HVACComponent.get
        if equip.to_ZoneHVACPackagedTerminalAirConditioner.is_initialized
          has_ptac = true
        elsif equip.to_ZoneHVACPackagedTerminalHeatPump.is_initialized
          has_pthp = true
        elsif equip.to_ZoneHVACUnitHeater.is_initialized
          has_unitheater = true
        end
      end
      # Test for hvac type by climate
      if climate_zone =~ /0A|0B|1A|1B|2A|2B|3A/
        if has_pthp == false
          pass_test = false
        end
      else
        if has_ptac == false
          pass_test = false
        end
      end
    end
    if climate_zone =~ /0A|0B|1A|1B|2A|2B|3A/
      assert(pass_test, "Baseline system selection failed for climate #{climate_zone}: should be PTHP for " + sub_text)
    else
      assert(pass_test, "Baseline system selection failed for climate #{climate_zone}: should be PTAC for " + sub_text)
    end
  end

  # Check if baseline system type is four pipe fan coil/ constant speed
  # @param model, sub_text for error messages
  def check_if_sz_cv(model, climate_zone, sub_text)
    # building fails if any zone is not packaged terminal unit
    # or if heat type is incorrect
    model.getThermalZones.sort.each do |thermal_zone|
      pass_test = false
      is_fpfc = false
      heat_type = ''
      thermal_zone.equipment.each do |equip|
        # Skip HVAC components
        next unless equip.to_HVACComponent.is_initialized

        equip = equip.to_HVACComponent.get
        is_fpfc = equip.to_ZoneHVACFourPipeFanCoil.is_initialized

        if is_fpfc
          # pass test for FPFC if at least one zone equip is FPFC; others may be exhaust fan, or possibly something else
          pass_test = true
        end
        if is_fpfc
          # Also check heat type
          equip = equip.to_ZoneHVACFourPipeFanCoil.get
          heat_type = model.coil_heat_type(equip.heatingCoil)
          if climate_zone =~ /0A|0B|1A|1B|2A|2B|3A/
            assert(heat_type == 'Electric', "Baseline system selection failed for climate #{climate_zone}: FPFC should have electric heat for " + sub_text)
          else
            assert(heat_type == 'Fuel', "Baseline system selection failed for climate #{climate_zone}: FPFC should have hot water heat for " + sub_text)
          end
        end
      end
      assert(pass_test, 'Baseline system selection failed: should be FPFC for ' + sub_text)
    end
  end

  # Check if baseline system type is a single-zone system with variable-air-volume fan
  #
  # @param model [OpenStudio::model::Model] OpenStudio model object
  def check_cmp_dtctr_system_type(model)
    zone_load_s = 0
    # Individual zone load check
    model.getThermalZones.each do |zone|
      # Get design cooling load of computer rooms
      zone.spaces.each do |space|
        if space.spaceType.get.standardsSpaceType.get == 'computer room'
          zone_load_w = zone.coolingDesignLoad.to_f
          zone_load_w *= zone.floorArea * zone.multiplier
          zone_load = OpenStudio.convert(zone_load_w, 'W', 'Btu/hr').get
          zone_load_s += zone_load
          if zone_load >= 600000
            # System 11 (PSZ-VAV) is required
            assert(check_if_sz_vav(model, zone), "Zone #{zone.name} should be served by a packaged single zone VAV system (system 11).")
          elsif zone_load < 600000
            # System 3 or 4 is required
            assert(check_if_psz(model, '', zone: zone), "Zone #{zone.name} should be served by a packaged single zone CAV system (system 3 or 4).")
          end
        end
      end
    end

    # Building load check
    return false unless zone_load_s > 3000000

    model.getThermalZones.each do |zone|
      zone.spaces.each do |space|
        if space.spaceType.get.standardsSpaceType.get == 'computer room'
          # System 11 is required
          assert(check_if_sz_vav(model, zone), "Zone #{zone.name} should be served by a packaged single zone VAV system (system 11) because building computer rooms peak load exceed 3,000, 000 Btu/h.")
        end
      end
    end
  end

  def check_if_sz_vav(model, zone)
    zone_system_check = false
    model.getAirLoopHVACUnitarySystems.each do |unit_system|
      # Check if the system is system 11 by checking if the load control type is SingleZoneVAV
      zone_system_check = true if unit_system.controllingZoneorThermostatLocation.get.name.to_s == zone.name.to_s &&
                                  unit_system.controlType == 'SingleZoneVAV' &&
                                  unit_system.coolingCoil.get.to_CoilCoolingWater.is_initialized
    end
    return zone_system_check
  end

  # Check if SAT requirements for system 5 through 8 are implemented
  #
  # @param prototypes_base [Hash] Baseline prototypes
  def check_sat_ctrl(prototypes_base)
    prototypes_base.each do |prototype, model_baseline|
      building_type, template, climate_zone, mod = prototype

      # Concatenate modifier functions and arguments
      mod_str = mod.flatten.join('_') unless mod.empty?

      model_baseline.getAirLoopHVACs.each do |airloop|
        # Baseline system type identified based on airloop HVAC name
        if airloop.name.to_s.include?('Sys5') ||
           airloop.name.to_s.include?('Sys6') ||
           airloop.name.to_s.include?('Sys7') ||
           airloop.name.to_s.include?('Sys8')
          # Get all SPM assigned to supply outlet node of the airloop
          spms = airloop.supplyOutletNode.setpointManagers
          spm_check = false

          # Report if multiple setpoint managers have been assigned to the air loop supply outlet node
          assert(false, 'Multiple setpoint manager have been assigned to the air loop supply outlet node.') unless spms.size == 1

          spms.each do |spm|
            if spm.to_SetpointManagerWarmest.is_initialized

              # Get SPM
              spm_w = spm.to_SetpointManagerWarmest.get

              # Retrieve SAT and SAT reset
              max = spm_w.maximumSetpointTemperature
              min = spm_w.minimumSetpointTemperature

              # Calculate difference
              dt_ip = max - min

              # Convert to dT F
              dt_si = OpenStudio.convert(dt_ip, 'K', 'R').get

              # Check if requirement is met for SPM
              spm_check = true if dt_si.round(0) == 5.0
            end
          end

          # Check if requirement is met for airloop
          assert(spm_check)
        end
      end
    end
  end

  # Set ZoneMultiplier to passed value for all zones
  # @param model, arguments[]
  def set_zone_multiplier(model, arguments)
    mult = arguments[0]
    model.getAirLoopHVACs.each do |air_loop|
      air_loop.thermalZones.each do |thermal_zone|
        thermal_zone.setMultiplier(mult)
      end
    end
    return model
  end

  # Change classroom space types to laboratory
  # Resulting in > 15,000 cfm lab exhaust
  # Add an exhaust fan to each zone
  # @param model, arguments[]
  def make_lab_high_distrib_zone_exh(model, arguments)
    # Convert all classrooms to laboratory
    convert_spaces_from_to(model, ['PrimarySchoolClassroom', 'laboratory'])

    # add exhaust fans to lab zones
    add_exhaust_fan_per_lab_zone(model)

    return model
  end

  # Change computer classroom space types to laboratory
  # Resulting in < 15,000 cfm lab exhaust
  # Add an exhaust fan to each zone
  # @param model, arguments[]
  def make_lab_low_distrib_zone_exh(model, arguments)
    convert_spaces_from_to(model, ['PrimarySchoolComputerRoom', 'laboratory'])
    # Populate hash to allow this space type to persist when protoype space types are replaced later
    # add exhaust fans to lab zones
    add_exhaust_fan_per_lab_zone(model)

    return model
  end

  # Change classroom space types to laboratory
  # Resulting in > 15,000 cfm lab exhaust
  # @param model, arguments[]
  def make_lab_high_system_exh(model, arguments)
    # Convert all classrooms to laboratory
    convert_spaces_from_to(model, ['PrimarySchoolClassroom', 'laboratory'])

    # reset OA make lab space OA exceed 17,000 cfm
    oa_name = 'PrimarySchool Classroom Ventilation'
    model.getDesignSpecificationOutdoorAirs.sort.each do |oa_def|
      if oa_def.name.to_s == oa_name
        oa_area = oa_def.outdoorAirFlowperFloorArea
        oa_def.setOutdoorAirFlowperFloorArea(0.0029)
      end
    end
    return model
  end

  # Convert specified space types to laboratory space type
  # @param model, from_bldg_space is name of existing space type to convert to laboratory
  def convert_spaces_from_to(model, arguments)
    from_bldg_space, to_bldg_space = arguments
    # Convert all spaces of type to convert to laboratory
    model.getSpaceTypes.sort.each do |space_type|
      next if space_type.floorArea == 0

      standards_space_type = if space_type.standardsSpaceType.is_initialized
                               space_type.standardsSpaceType.get
                             end
      std_bldg_type = space_type.standardsBuildingType.get
      bldg_type_space_type = std_bldg_type + space_type.standardsSpaceType.get
      if bldg_type_space_type == from_bldg_space
        space_type.setStandardsSpaceType(to_bldg_space)
        # Populate hash to allow this space type to persist when protoype space types are replaced later
        @lpd_space_types_alt[std_bldg_type + to_bldg_space] = to_bldg_space
      end
    end
    return model
  end

  # Change (medium) office space types to computer room
  #
  # @param model [OpenStudio::model::Model] OpenStudio model object
  # @param arguments [Array] Not used
  def convert_spaces_to_cmp_rms(model, arguments)
    convert_spaces_from_to(model, ['OfficeWholeBuilding - Md Office', 'computer room'])
    return model
  end

  # Add exhaust fan object to each lab zone in model
  # @param model
  def add_exhaust_fan_per_lab_zone(model)
    model.getThermalZones.sort.each do |thermal_zone|
      lab_is_found = false
      zone_area = 0
      thermal_zone.spaces.each do |space|
        space_type = space.spaceType.get.standardsSpaceType.get
        if space_type == 'laboratory'
          lab_is_found = true
          zone_area += space.floorArea
        end
      end
      if lab_is_found
        # add an exhaust fan
        zone_exhaust_fan = OpenStudio::Model::FanZoneExhaust.new(model)
        zone_exhaust_fan.setName(thermal_zone.name.to_s + ' Exhaust Fan')
        zone_exhaust_fan.setFanEfficiency(0.6)
        zone_exhaust_fan.setPressureRise(200)

        # set air flow above threshold for isolation of lab spaces on separate hvac system
        # A rate of 0.5 cfm/sf gives 17,730 cfm total exhaust
        exhaust_cfm = 0.5 * zone_area
        maximum_flow_rate = OpenStudio.convert(exhaust_cfm, 'cfm', 'm^3/s').get
        zone_exhaust_fan.setMaximumFlowRate(maximum_flow_rate)
        zone_exhaust_fan.setEndUseSubcategory('Zone Exhaust Fans')
        zone_exhaust_fan.addToThermalZone(thermal_zone)
      end
    end
  end

  # Change model to different building type
  # @param model, arguments => new building type
  def change_bldg_type(model, arguments)
    bldg_type_new = arguments[0]
    @bldg_type_alt_now = bldg_type_new
    return model
  end

  # Remove transformer from model
  # @param model [OpenStudio::model::Model] OpenStudio model object
  # @param arguments [Array] List of arguments
  def remove_transformer(model, arguments)
    model.getElectricLoadCenterTransformers.each(&:remove)
    return model
  end

  # Increase the size of the skylights in a model
  # @param model [OpenStudio::model::Model] OpenStudio model object
  # @param arguments [Array] List of arguments
  def increase_skylight_size(model, arguments)
    mult = arguments[0]
    model.getSpaces.sort.each do |space|
      next if @prototype_creator.space_conditioning_category(space) == 'Unconditioned'

      # Loop through all surfaces in this space
      space.surfaces.sort.each do |surface|
        # Skip non-outdoor surfaces
        next unless surface.outsideBoundaryCondition == 'Outdoors'

        # Skip non-walls
        next unless surface.surfaceType == 'RoofCeiling'

        # Subsurfaces in this surface
        surface.subSurfaces.sort.each do |ss|
          next unless ss.subSurfaceType == 'Skylight'

          # increase the size of the skylight
          @prototype_creator.sub_surface_reduce_area_by_percent_by_shrinking_toward_centroid(ss, mult)
        end
      end
    end

    return model
  end

  # Applies a multipler to increase the design cooling load of datacenters
  #
  # @param model [OpenStudio::model::Model] OpenStudio model object
  # @param epd_multiplier [Array] EPD multiplier
  # @returns [OpenStudio::model::Model]
  def increase_computer_rooms_epd(model, epd_multiplier)
    model.getThermalZones.each do |zone|
      zone.spaces.each do |space|
        if space.spaceType.get.standardsSpaceType.get.to_s.downcase.include?('data center') ||
           space.spaceType.get.standardsSpaceType.get.to_s.downcase.include?('computer room')
          elec_eqp = space.spaceType.get.electricEquipment
          elec_eqp[0].setMultiplier(epd_multiplier[0])
        end
      end
    end
    return model
  end

  # Run test suite for the ASHRAE 90.1 appendix G Performance
  # Rating Method (PRM) baseline automation implementation
  # in openstudio-standards.
  def test_create_prototype_baseline_building
    # Select test to run
    tests = [
      'wwr',
      'srr',
      'envelope',
      'lpd',
      'isresidential',
      'daylighting_control',
      'light_occ_sensor',
      'infiltration',
      'hvac_baseline',
      'sat_ctrl'
    ]

    # Get list of unique prototypes
    prototypes_to_generate = get_prototype_to_generate(tests, @@prototype_list)
    # Generate all unique prototypes
    prototypes_generated = generate_prototypes(prototypes_to_generate)
    # Create all unique baseline
    prototypes_baseline_generated = generate_baseline(prototypes_generated, prototypes_to_generate)
    # Assign prototypes and baseline to each test
    prototypes = assign_prototypes(prototypes_generated, tests, prototypes_to_generate)
    prototypes_base = assign_prototypes(prototypes_baseline_generated, tests, prototypes_to_generate)

    # Run tests
    check_wwr(prototypes_base['wwr']) if tests.include? 'wwr'
    check_srr(prototypes_base['srr']) if tests.include? 'srr'
    check_daylighting_control(prototypes_base['daylighting_control']) if tests.include? 'daylighting_control'
    check_residential_flag(prototypes_base['isresidential']) if tests.include? 'isresidential'
    check_envelope(prototypes_base['envelope']) if tests.include? 'envelope'
    check_lpd(prototypes_base['lpd']) if tests.include? 'lpd'
    check_light_occ_sensor(prototypes['light_occ_sensor'], prototypes_base['light_occ_sensor']) if tests.include? 'light_occ_sensor'
    check_infiltration(prototypes['infiltration'], prototypes_base['infiltration']) if tests.include? 'infiltration'
    check_hvac_type(prototypes_base['hvac_baseline']) if tests.include? 'hvac_baseline'
    check_sat_ctrl(prototypes_base['sat_ctrl']) if tests.include? 'sat_ctrl'
  end
end
