require_relative '../../../helpers/minitest_helper'
require_relative '../../../helpers/create_doe_prototype_helper'
require 'json'

# This checks that skylight wells are correctly autogenerated in BTAP.
class NECB_Skylights_Tests < Minitest::Test
  def test_necb_skylights()
    outd = 'output/test_necb_skylights'
    eres = '../expected_results/necb_skylights_expected_results.json'
    tres = '../expected_results/necb_skylights_test_results.json'
    sizd = 'sizing_folder'

    plnums = ["LargeOffice", "MediumOffice"]
    attics = ["FullServiceRestaurant", "QuickServiceRestaurant", "SmallOffice"]

    # File/folder paths.
    @output_folder         = File.join(__dir__, outd)
    @expected_results_file = File.join(__dir__, eres)
    @test_results_file     = File.join(__dir__, tres)
    @sizing_run_dir        = File.join(@output_folder, sizd)
    @test_results_array    = []

    # Intial test condition.
    @test_passed = true

    @epws = ['CAN_AB_Calgary.Intl.AP.718770_CWEC2020.epw']

    # Skylight wells are autogenerated by OSut's 'addSkylights'. OSut is a TBD
    # extended dependency, called in BTAP as: "TBD.addSkylights()". This is
    # enabled in BTAP by passing the optional :srr_opt = 'osut', which is by
    # default an empty string. This leaves the door open for future options.
    @options = ['osut']

    # Tested models are limited to NECB2011 Prototypes that hold unoccupied
    # spaces below roofs (e.g. attics or plenums). Both require skylight wells
    # to toplight occupied spaces below.
    @buildings = [
      'FullServiceRestaurant',
      'LargeOffice',
      'MediumOffice',
      # 'NorthernEducation',  # *
      # 'NorthernHealthCare', # *
      'QuickServiceRestaurant',
      'SmallOffice'
    ]

    # (*) 'NorthernEducation' and 'NorthernHealthCare' have neither:
    #       - Building.standardsNumberOfStories
    #       - Building.standardsNumberOfAboveStories
    #
    #     ... and so both templates/models fail early on, irrespective of
    #         BTAP::Activity features - @todo.

    # NOTE: Skipping NorthernEducation for now:
    #   Minitest::UnexpectedError: RuntimeError: validation of model failed.

    # Range of test options. NECB2011 for now. Skipping later NECBs - they're
    # systematically easier to deploy, given their lower reference building SRR
    # targets (e.g. 2% vs 5%). BTAPPRE1980 cases are likely worth testing at
    # some point, given their unique decision matrix.
    @templates = ['NECB2011']

    fdback = []
    fdback << ""
    fdback << "BTAP/Skylight Unit Tests"
    fdback << "~~~~ ~~~~ ~~~~ ~~~~ ~~~~"

    @epws.sort.each            do |epw     |
      @options.sort.each       do |option  |
        @buildings.sort.each   do |building|
          @templates.sort.each do |template|
            cas = "CASE #{option} | #{building} (#{template})"
            srr = case template
                  when 'NECB2020' then 0.02
                  when 'NECB2017' then 0.02
                  else                 0.05 # e.g. NECB2011, NECB2015
                  end

            st    = Standard.build(template)
            model = st.model_create_prototype_model(template:template,
                                                    epw_file: epw,
                                                    building_type: building,
                                                    construction_opt: 'structure',
                                                    srr_opt: option,
                                                    sizing_run_dir: @sizing_run_dir)

            # OSut addSkylight-specific info/warning/error feedback.
            err_msg = "BTAP/Sky OSut Hash (#{cas})?"
            assert_kind_of(Hash, st.osut, err_msg)
            err_msg = "BTAP/Sky: Missing nominal gross roof area (#{cas})?"
            assert(st.osut.key?(:gra0), err_msg)
            err_msg = "BTAP/Sky: Missing effective gross roof area (#{cas})?"
            assert(st.osut.key?(:graX), err_msg)
            err_msg = "BTAP/Sky: Nominal gross roof area (#{cas})?"
            assert_kind_of(Float, st.osut[:gra0], err_msg)
            err_msg = "BTAP/Sky: Effective gross roof area (#{cas})?"
            assert_kind_of(Float, st.osut[:graX], err_msg)
            err_msg = "BTAP/Sky: Negative nomianl gross roof area (#{cas})?"
            assert(st.osut[:gra0] > 0, err_msg)
            err_msg = "BTAP/Sky: Negative effective gross roof area (#{cas})?"
            assert(st.osut[:graX] > 0, err_msg)
            err_msg = "BTAP/Sky: Missing log status (#{cas})?"
            assert(st.osut.key?(:status), err_msg)
            err_msg = "BTAP/Sky: Log status (#{cas})?"
            assert_kind_of(Integer, st.osut[:status], err_msg)
            err_msg = "BTAP/Sky: Missing OSut logs (#{cas})?"
            assert(st.osut.key?(:logs), err_msg)
            err_msg = "BTAP/Sky: OSut logs (#{cas})?"
            assert_kind_of(Array, st.osut[:logs], err_msg)

            # Tally skylight areas. Compare with GRAs.
            skm2 = 0

            model.getSubSurfaces.each do |sub|
              next unless sub.subSurfaceType.downcase == "skylight"

              skm2 += sub.grossArea
            end

            assert(skm2 > 0, "BTAP/Sky: area (#{cas})?")
            gra0 = st.osut[:gra0] # gross roof area (GRA) in m2, as per SDK
            graX = st.osut[:graX] # GRA minus overhang areas (see SmallOffice)

            # The "SmallOffice" has an unconditioned (unoccupied) attic with
            # roof overhangs. The overhanged sections of attic roof surfaces
            # should be excluded from the calculated gross roof area, as per
            # ASHRAE 90.1 definitions (NECB definitions are more vague). See:
            #
            #   github.com/rd2/osut/blob/
            #   117c7dceb59fd8aab771da8ba672c14c97d23bd0/
            #   lib/osut/utils.rb#L6304
            #
            # Relying on the total area of attic roof surfaces (for SRR%)
            # exagerrates required skylight area targets, often by 10% to 15%.
            # Such targets are harder to meet when dealing with skylight wells.
            # This also leads to unfair assessments of NECB rulesets. This
            # issue only applies for attics - not plenums.
            #
            # Since neither OpenStudio nor OpenStudio-Standards consider this
            # as an issue (i.e. ASHRAE 90.1 doesn't require NECB fixed SRRs),
            # BTAP would be perpetually 'swimming against the tide' if forcing
            # the use of revised GRA calculations. An easier alternative is
            # to lower proportionately the requested SRR%, while logging an
            # informative warning to the user, e.g.:
            #
            #   nominal NECB2011 SRR% =  5.0%
            #       ratio graX / gra0 = 90.0%
            # effective NECB2011 SRR% =  4.5%
            #
            # EnergyPlus, OpenStudio & OpenStudio-Standards would report here a
            # SRR% of 4.5%. The effective 'ratio' would vary based on geometry,
            # e.g. larger building footprint, wider overhangs.
            if building == "SmallOffice"
              err_msg = "BTAP/Sky: GRA0 <= GRAX (#{cas})?"
              assert(gra0.round > graX.round, err_msg)
            else
              err_msg = "BTAP/Sky: GRA0 != GRAX (#{cas})?"
              assert_equal(gra0.round, graX.round, err_msg)
            end

            lc = nil

            # Ensure insulated skylight well walls in attics.
            if attics.include?(building)
              spaces = model.getSpaces.reject { |s| s.partofTotalFloorArea }
              err_msg = "BTAP/Sky: ! 1x attic (#{cas})?"
              assert_equal(spaces.size, 1, err_msg)
              space = spaces.first
              err_msg = "BTAP/Sky: Conditioned attic (#{cas})?"
              assert(TBD.unconditioned?(space))

              space.surfaces.each do |s|
                next unless s.surfaceType.downcase == "wall"
                next if s.outsideBoundaryCondition.downcase == "outdoors"
                err_msg = "BTAP/Sky: Non-defaulted skylight construction (#{cas})?"
                assert(s.isConstructionDefaulted)
                next unless lc.nil?

                lc = s.construction
                err_msg = "BTAP/Sky: Skylight well wall construction #{cas}?"
                refute(lc.empty?)
                lc = lc.get.to_LayeredConstruction
                err_msg = "BTAP/Sky: Layered well wall construction #{cas}?"
                refute(lc.empty?)
                lc = lc.get
                err_msg = "BTAP/Sky: Uninsulated well wall (#{cas})?"
                assert_equal(TBD.rsi(lc, s.filmResistance).round(2), 4.85)
              end
            elsif plnums.include?(building)
              spaces = model.getSpaces.reject { |s| s.partofTotalFloorArea }
              err_msg = "BTAP/Sky: ! 3x plenums (#{cas})?"
              assert_equal(spaces.size, 3, err_msg)

              # Pick tallest plenum.
              top = nil

              spaces.each do |space|
                space.surfaces.each do |s|
                  ty = s.surfaceType.downcase
                  bc = s.outsideBoundaryCondition.downcase
                  next unless ty == "roofceiling"
                  next unless bc == "outdoors"

                  top = space
                  break
                end
              end

              err_msg = "BTAP/Sky: Top plenum (#{cas})?"
              refute_nil(top, err_msg)

              err_msg = "BTAP/Sky: Unconditioned plenum (#{cas})?"
              refute(TBD.unconditioned?(top))

              top.surfaces.each do |s|
                next unless s.surfaceType.downcase == "wall"
                next if s.outsideBoundaryCondition.downcase == "outdoors"
                err_msg = "BTAP/Sky: Non-defaulted skylight construction (#{cas})?"
                assert(s.isConstructionDefaulted)
                next unless lc.nil?

                lc = s.construction
                err_msg = "BTAP/Sky: Skylight well wall construction #{cas}?"
                refute(lc.empty?)
                lc = lc.get.to_LayeredConstruction
                err_msg = "BTAP/Sky: Layered well wall construction #{cas}?"
                refute(lc.empty?)
                lc = lc.get
                err_msg = "BTAP/Sky: Insulated well wall (#{cas})?"
                assert_equal(TBD.rsi(lc, s.filmResistance).round(2), 0.56)
              end
            end

            ratio = skm2 / graX
            assert_equal(ratio.round(2), srr, "BTAP: SRR (#{cas})?")

            # Higher level feedback.
            fdback << ""
            fdback << cas
            status = st.osut[:status]

            st.osut[:logs].each do |log|
              assert_kind_of(log, Hash, "BTAP: log (#{cas})?")
              assert(log.key?(:level), "BTAP: log level (#{cas})?")
              assert(log.key?(:message), "BTAP: log message (#{cas})?")
              next if log[:level] < 1 # 'INFO'
              next unless log.include?("(OSut::addSkylights)")

              fdback << log[:message]
            end
          end                   # |template|
        end                     # |building|
      end                       # |option  |
    end                         # |epw     |

    # Temporary.
    fdback.each { |msg| puts msg }

    # Save test results to file.
    File.open(@test_results_file, 'w') do |f|
      f.write(JSON.pretty_generate(@test_results_array))
    end
  end

end
